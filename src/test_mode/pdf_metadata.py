#! /usr/bin/env python3
# -*- coding: utf-8 -*-

"""PDF Metadata

This module is an automated utility that extracts metadata from
a PDF file, and structures the output in the format of an HTML
report.

Dependencies:
    This script requires that the prior installation of the 
    QPDF utility (http://qpdf.sourceforge.net) in order to 
    decrypt encrypted PDF files.

Date: 
    5 December 2018

Version: 
    0.2

License:
    GPL v3.0

Authors: 
    nxl4@protonmail.com
"""

__email_addr__  = 'nxl4@protonmail.com'
__gitlab_addr__ = 'https://gitlab.com/nxl4/pdf-metadata'
__version__     = '0.2'

import argparse
import csv
import hashlib
import os
import re
import shlex
import shutil
from datetime import datetime
from functools import partial
from shutil import copyfile
from subprocess import Popen, PIPE

HTML_TOP = """
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>PDF Metadata Report</title>
</head>
<style>
    code {{
        background-color: #eee;
        border-radius: 3px;
        font-family: courier, monospace;
        padding: 0 3px;
        white-space: pre-wrap;
        white-space: -moz-pre-wrap;
        white-space: -pre-wrap;
        white-space: -o-pre-wrap;
        word-wrap: break-word;
        display: block;
        font-size: smaller;
    }}
    table, th, td {{
        border: 1px solid black;
    }}
</style>
<body>
<h1>PDF Metadata Report</h1>
<h2><i>Generated by <a href="{0}">PDF Metadata</a>, Version {1}</i></h2>
<hr>
<strong>Contents</strong>
<ul>
    <li><a href="#FileSysMeta">File System Metadata</a></li>
    <ul>
        <li><a href="#FileStats">File Statistics</a></li>
        <li><a href="#FileHashes">File Hashes</a></li>
    </ul>
    <li><a href="#AppMeta">Application Metadata</a></li>
    <ul>
        <li><a href="#PDFVer">PDF Version</a></li>
        <li><a href="#EncryptStat">Encryption Status</a></li>
        <li><a href="#DocInfoDir">Document Information Dictionary</a></li>
        <li><a href="#XMPMeta">XMP Metadata</a></li>
    </ul>
</ul>
<hr>
<a name="FileSysMeta"></a>
<h2>File System Metadata</h2>
<a name="FileStats"></a>
<h3>File Statistics</h2>
<p>File Path:</p>
<p><code>{2}</code></p>
<p>File Size:</p>
<p><code>{3}</code></p>
<p>Time of Most Recent Access:</p>
<p><code>{4}</code></p>
<p>Time of Most Recent Content Change:</p>
<p><code>{5}</code></p>
<p>Time of Most Recent Metadata Change:</p>
<p><code>{6}</code></p>
<a name="FileHashes"></a>
<h3>File Hashes</h3>
<p>MD5 Hash:</p>
<p><code>{7}</code></p>
<p>SHA1 Hash:</p>
<p><code>{8}</code></p>
<p>SHA224 Hash:</p>
<p><code>{9}</code></p>
<p>SHA256 Hash:</p>
<p><code>{10}</code></p>
<p>SHA384 Hash:</p>
<p><code>{11}</code></p>
<p>SHA512 Hash:</p>
<p><code>{12}</code></p>
<hr>
<a name="AppMeta"></a>
<h2>Application Metadata</h2>
<a name="PDFVer"></a>
<h3>PDF Version</h3>
<p>The magic number identifies this PDF file as being version:</p>
<p><code>{13}</code></p>\n"""

HTML_CRYPT_HEAD = """
<a name="EncryptStat"></a>
<h3>Encryption Status</h3>\n"""

HTML_CRYPT_TRUE = "<p>This file is encrypted, "

HTML_CRYPT_FALSE = "<p>This file is not encrypted.</p>\n"

HTML_DECRYPT_PASS_PW = """
and was successfully decrypted with QPDF, using the password:</p>
<p><code>{0}</code></p>\n"""

HTML_DECRYPT_PASS_DF = """
and was successfully decrypted with QPDF, using the default 
blank password.</p>\n"""

HTML_DECRYPT_FAIL_PW = """
but was not successfully decrypted with QPDF, using the 
password:</p>
<p><code>{0}</code></p>
<p>This attempt generated the following error message:</p>
<p><code>{1}</code></p>\n"""

HTML_DECRYPT_FAIL_DF = """
'but was not successfully decrypted with QPDF, using the 
default password.</p>
<p>This attempt generated the following error message:</p>
<p><code>{0}</code></p>\n"""

HTML_DOC_REF = """
<a name="DocInfoDir"></a>
<h3>Document Information Dictionary</h3>
<p>There are a total of {0} document information directory 
references located in the PDF file:</p>\n"""

HTML_DOC_OBJ = """
<p>There are a total of {0} document information dictionary 
objects located in the PDF file:</p>\n"""

HTML_XMP_REF = """
<a name="XMPMeta"></a>
<h3>XMP Metadata</h3>
<p>There are a total of {0} XMP metadata references located 
in the PDF file:</p>\n"""

HTML_XMP_OBJ = """
<p>There are a total of {0} XMP metadata objects located in 
the PDF file:</p>\n"""

HTML_BOTTOM = """
<hr>
<i>PDF Metadata &#169; 2018, <a href="mailto:{0}">{1}</a></i>
</body>
</html>\n"""

TITLE = """
 +---+---+---+---+
 | {0} | {1} | {2} | {3} |
 +---+---+---+---+---+
     | {4} | {5} | {6} | {7} |
     +---+---+---+---+---+
         | {8} | {9} | {10} | {11} |
         +---+---+---+---+

 PDF Metadata, {12}
"""

class Color:
    """CLI color class

    This class defines colors used to print to the command line
    interface. 
    """
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    DARKCYAN = '\033[36m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'


class BinaryPdfForensics:
    """Binary PDF forensics class

    This class contains a variety of methods needed to do 
    forensic analysis of PDF files.

    Attributes:
        file_path: The path (full or truncated) of a valid
        PDF file.

        temp_path: The hard-coded truncated path of the 
        temporary PDF files used for decryption and metadata 
        extraction.

        output_path: The path (full or truncated) of the output
        file.

        password: The password used to decrypt an encrypted
        PDF file. This value defaults to None is no input
        is provided.
    """
    def __init__(self, 
                 file_path, 
                 output_path, 
                 password=None):
        """Inits class object with attributes"""
        self.file_path = file_path
        self.temp_path = 'temp.pdf'
        self.output_path = output_path
        self.password = password


    def pdf_magic(self):
        """Tests if file contains PDF magic number

        This method reads the input file as a binary stream,
        and interrogates the first four bytes, to determine
        if they decode to the PDF magic number ('%PDF'). This
        is used to determine whether or not a file, regardless
        of its extension, is a PDF.

        Args:
            file_path: The path (can be full or abbreviated) of
            the file to be tested.

        Returns:
            This method returns a tuple containing two values:
            (1) a Boolean value identifying whether or not the 
            input path is a PDF file, and (2) a string description
            of the magic assessment. For PDF files, this string
            value will contain the version of the PDF. Example of
            the magic number:

                %PDF-1.4

        Exceptions:
            UnicodeDecodeError: Bytes cannot be decoded.

            IsADirectoryError: Input is a directory.

            FileNotFoundError: Input path does not exist.
        """
        try:
            with open(self.file_path, 'rb') as raw_file:
                read_file = raw_file.read()
                magic_val = read_file[0:4].decode()
                pdf_version = read_file[1:8].decode()
                if magic_val == '%PDF':
                    return (True, pdf_version)
                else:
                    return (False, 'Non-PDF File')
        except UnicodeDecodeError:
            return (False, 'Non-PDF File')
        except IsADirectoryError:
            return (False, 'Directory')
        except FileNotFoundError:
            return (False, 'File Not Found')


    def get_crypt_ref(self):
        """Tests if a PDF file is encrypted

        This method reads the input file as a binary stream,
        and then performs a regex search, to determine if the
        trailer contains a reference to an encryption object.
        This method is only applicable to valid PDF file, and
        should alwaye be used after the pdf_magic() method has
        determined that the file is a PDF. 

        Args:
            file_path: The path (can be full or abbreviated) of
            the file to be tested.

        Returns:
            This method returns a tuple containing two values:
            (1) a Boolean value identifying whether or not the 
            PDF file contains an /Encrypt reference, and (2) a 
            list of any located binary encryption object 
            reference strings. Example of the encryption value:

                /Encrypt 3 0 R
        """
        with open(self.file_path, 'rb') as raw_file:
            read_file = raw_file.read()
            regex = b'[/]Encrypt[ ]*[0-9].*?R'
            pattern = re.compile(regex, re.DOTALL)
            encryption_ref = re.findall(pattern, read_file)
            encryption_ref = de_dupe_list(encryption_ref)
            if len(encryption_ref) == 0:
                encrypted = False
            else:
                encrypted = True
            return (encrypted, encryption_ref)


    def copy_file(self):
        """Copies un-encrypted PDF file to temp directory

        This method begins by removing any existing temporary
        directories or files, and creating a new temporary
        directory to copy the PDF file into for subsequent
        analysis. It then executes a copy function to copy the
        PDF file.

        Args:
            file_path: The path (can be full or abbreviated) of
            the file to be tested.
            
            temp_path: The hard-coded truncated path of the 
            temporary PDF files used for decryption and metadata 
            extraction.
        Return:
            This method returns a boolean value based on the 
            success of the copy function.
        """ 
        # remove and re-create temporary directory
        if os.path.isfile(self.temp_path):
            os.remove(self.temp_path)
        if os.path.isdir('.tmp/'):
            pass
        else:
            os.mkdir('.tmp/')
        # copy file into temporary directory
        copyfile(self.file_path, self.temp_path)
        # calculate return value
        if os.path.isfile(self.temp_path):
            return True
        else:
            return False


    def decrypt_file(self):
        """Decrypts encrypted PDF files

        This method begins by testing the password value. If
        no password is provided, the default password value is
        stored. A temporary directory is created to store the 
        decrypted version of the PDF file, and any previously
        existing temporary directories and files are removed. 
        The QPDF command is then invoked to decrypt the file, 
        saving the decrypted file in the temporary directory. 
        If the QPDF command fails, then the original file is
        copied into the temporary directory for use with sub-
        sequent functions.

        Args:
            file_path: The path (can be full or abbreviated) of
            the file to be tested.
            
            temp_path: The hard-coded truncated path of the 
            temporary PDF files used for decryption and metadata 
            extraction.

            output_path: The path (full or truncated) of the 
            output file.

            password: The password used to decrypt an encrypted
            PDF file. This value defaults to None is no input
            is provided.

        Returns:
            This method returns a tuple with four elements: (1) 
            the return code pushed by the QPDF command, (2) the
            password used in the command to decrypt the file, (3) 
            any output generated by the command, and (4) any
            error messages generated by the command.
        """ 
        # capture input password
        if self.password is None:
            pw = ""
        else:
            pw = str(self.password)
        # remove and re-create temporary directory
        if os.path.isfile(self.temp_path):
            os.remove(self.temp_path)
        if os.path.isdir('.tmp/'):
            pass
        else:
            os.mkdir('.tmp/')
        # decrypt PDF file into temporary directory
        qpdf = "qpdf --password={0} --decrypt '{1}' '{2}'".format(
            pw,
            self.file_path,
            self.temp_path)
        args = shlex.split(qpdf)
        run_qpdf = Popen(args, stdout=PIPE, stderr=PIPE)
        # capture and pass output and return codes
        output, error = run_qpdf.communicate()
        return_code = run_qpdf.returncode
        # run copy function is decryption fails
        if os.path.isfile(self.temp_path):
            pass
        else:
            copyfile(self.file_path, self.temp_path)
        return (return_code, pw, output, error)


    def temp_clean(self):
        """Cleans up temporary directory

        This method is used to remove any temporary directories
        that were created by the script.

        Args:
            temp_path: The hard-coded truncated path of the 
            temporary PDF files used for decryption and metadata 
            extraction.
        """
        
        try:
            shutil.rmtree('.tmp/')
            return True
        except:
            return False


    def get_info_ref(self):
        """Tests if a PDF file contains an /Info reference

        This method reads the input file as a binary stream,
        and then performs a regex search, to determine if it 
        contains a document information dictionary reference. 
        This method only works with valid PDF files, and will 
        produce unexpected errors if used on other file types. 
        PDF file type should be verified first with the 
        pdf_magic() method.

        Args:
            temp_path: The path (can be full or abbreviated) of
            the file to be tested.

        Returns:
            This method returns a tuple containing two values:
            (1) a Boolean value identifying whether or not the PDF
            contains the /Info reference, and (2) a list of any
            located binary document information dictionary string
            references. Example of the info value:

                /Info 2 0 R
        """
        with open(self.file_path, 'rb') as raw_file:
            read_file = raw_file.read()
            regex = b'[/]Info[\s0-9]*?R'
            pattern = re.compile(regex, re.DOTALL)
            info_ref = re.findall(pattern, read_file)
            info_ref = de_dupe_list(info_ref)
            if len(info_ref) == 0:
                info_ref_exists = False
            else:
                info_ref_exists = True
            return (info_ref_exists, info_ref)


    def get_xmp_ref(self):
        """Tests if a PDF file contains a /Metadata reference

        This method reads the input file as a binary stream,
        and then performs a regex search, to determine if it
        contains an XMP metadata reference. This method only
        works with valid PDF files, and will produce unexpected
        errors if used on other file types. PDF file type should
        be verified first with the pdf_magic() method.

        Args:
            temp_path: The path (can be full or abbreviated) of
            the file to be tested.

        Returns:
            This method returns a tuple containing two values:
            (1) a Boolean value identifying whether or not the PDF
            contains the /Metadata reference, and (2) a list of
            any located binary XMP metadata string references.
            Example of the XMP metadata reference:

                /Metadata 3 0 R
        """
        with open(self.file_path, 'rb') as raw_file:
            read_file = raw_file.read()
            regex = b'[/]Metadata[\s0-9]*?R'
            pattern = re.compile(regex, re.DOTALL)
            xmp_ref = re.findall(pattern, read_file)
            xmp_ref = de_dupe_list(xmp_ref)
            if len(xmp_ref) == 0:
                xmp_ref_exists = False
            else:
                xmp_ref_exists = True
            return (xmp_ref_exists, xmp_ref)


    def get_info_obj(self):
        """Extracts /Info objects from PDF file
        
        This method reads the input file as a binary stream,
        and then calls the get_info_ref() function to get any
        /Info references in the file. Any located /Info refs
        are then used to locate any matching /Info objects
        in the file. Example of the /Info object:

            2 0 obj
            << ... >>
            endobj

        Args:
            temp_path: The path (can be full or abbreviated) of
            the file to be tested.

        Returns:
            This method returns a tuple containing the following
            elements: (1) a boolean value of whether or not an
            /Info object exists, and (2) a dictionary which maps
            the /Info references with their objects.
        """
        with open(self.file_path, 'rb') as raw_file:
            read_file = raw_file.read()
            info_ref_tuple = BinaryPdfForensics.get_info_ref(self)
            info_obj_dict = {}
            for ref in info_ref_tuple[1]:
                info_ref = ref.decode()
                info_ref = info_ref.replace('/Info ', '') \
                                   .replace(' R', '')
                info_ref = str.encode(info_ref)
                regex = b'[^0-9]' + info_ref + b'[ ]obj.*?endobj'
                pattern = re.compile(regex, re.DOTALL)
                info_obj = re.findall(pattern, read_file)
                info_obj = de_dupe_list(info_obj)
                if len(info_obj) > 0:
                    for obj in info_obj:
                        info_obj_dict[ref] = obj
            if len(info_obj_dict) == 0:
                info_obj_exists = False
            else:
                info_obj_exists = True
            return (info_obj_exists, info_obj_dict)


    def get_xmp_obj(self):
        """Extracts /Metadata objects from PDF file
        
        This method reads the input file as a binary stream,
        and then calls the get_xmp_ref() function to get any
        /Info references in the file. Any located /Metadata refs
        are then used to locate any matching /Metadata objects
        in the file. Example of /Metadata object:

            3 0 obj
            <</Length 4718/Subtype/XML/Type/Metadata>>stream
            <?xpacket begin="ï»¿" id="W5M0MpCehiHzreSzNTczkc9d"?>
            <x:xmpmeta ...
            </x:xmpmeta>
            <?xpacket end="w"?>
            endstream
            endobj

        Args:
            temp_path: The path (can be full or abbreviated) of
            the file to be tested.

        Returns:
            This method returns a tuple containing the following
            elements: (1) a boolean value of whether or not an
            /Metadata object exists, and (2) a dictionary which 
            maps the /Metadata references with their objects.
        """
        with open(self.file_path, 'rb') as raw_file:
            read_file = raw_file.read()
            xmp_ref_tuple = BinaryPdfForensics.get_xmp_ref(self)
            xmp_obj_dict = {}
            for ref in xmp_ref_tuple[1]:
                xmp_ref = ref.decode()
                xmp_ref = xmp_ref.replace('/Metadata ', '') \
                                 .replace(' R', '')
                xmp_ref = str.encode(xmp_ref)
                regex = b'[^0-9]' + xmp_ref + b'[ ]obj.*?endobj'
                pattern = re.compile(regex, re.DOTALL)
                xmp_obj = re.findall(pattern, read_file)
                xmp_obj = de_dupe_list(xmp_obj)
                if len(xmp_obj) > 0:
                    for obj in xmp_obj:
                        xmp_obj_dict[ref] = obj
            if len(xmp_obj_dict) == 0:
                xmp_obj_exists = False
            else:
                xmp_obj_exists = True
            return (xmp_obj_exists, xmp_obj_dict)


    def file_stats(self):
        """Calculate file statistics

        This method calculates the statistics which constitute
        a file's file system metadata, turning them into human
        readable strings ready for insertion into the metadata
        report.

        Args:
            file_path: The path (can be full or abbreviated) of
            the file to be tested.

        Returns:
            This method returns a list containing five string
            elements: the file's (1) absolute path, (2) human
            readable size, (3) access time, (4) modification
            time, and (5) change time.
        """
        stats = os.stat(self.file_path)
        file_abspath = os.path.abspath(self.file_path)
        # calculate file size in bytes
        byte_size = stats[6]
        if byte_size < 1000:
            human_size = str(byte_size) + ' bytes'
        # calculate file size in KBs
        elif byte_size < 1000000:
            human_size = '{0} KB ({1} bytes)'.format(
                str(byte_size / 1000.0),
                str(byte_size)
                )
        # calculate file size in MBs
        elif byte_size < 1000000000:
            human_size = '{0} MB ({1} bytes)'.format(
                str(byte_size / 1000000.0),
                str(byte_size)
                )
        # calculate file size in GBs
        elif byte_size < 1000000000000:
            human_size = '{0} GB ({1} bytes)'.format(
                str(byte_size / 1000000000.0),
                str(byte_size)
                )
        # calculate file size in TBs
        elif byte_size < 1000000000000000:
            human_size = '{0} TB ({1} bytes)'.format(
                str(byte_size / 1000000000000.0),
                str(byte_size)
                )
        # calculate file access time
        atime = datetime.utcfromtimestamp(int(stats[7])). \
            strftime('%Y-%m-%d %H:%M:%S')
        # calculate file modification time
        mtime = datetime.utcfromtimestamp(int(stats[8])). \
            strftime('%Y-%m-%d %H:%M:%S')
        # calculate file change time
        ctime = datetime.utcfromtimestamp(int(stats[9])). \
            strftime('%Y-%m-%d %H:%M:%S')
        file_sys_meta = [
            file_abspath, 
            human_size,
            atime,
            mtime,
            ctime
            ]
        return file_sys_meta


    def file_hashes(self):
        """Calculates file hashes

        This method reads the input file as a binary stream,
        and then calculates hash digests of the file for each
        of the hashing algorithms supported by Python's
        hashlib.

        Args:
            file_path: The path (can be full or abbreviated) of
            the file to be tested.

        Returns:
            This method returns a list of string values for the
            digest of the file's hash for each hashing algorithm:
            (1) MD5, (2) SHA1, (3) SHA224, (4) SHA256, (5) SHA384,
            (6) SHA512.
        """
        with open(self.file_path, 'rb') as f:
            # initiate hashing algorithms
            d_md5 = hashlib.md5()
            d_sha1 = hashlib.sha1()
            d_sha224 = hashlib.sha224()
            d_sha256 = hashlib.sha256()
            d_sha384 = hashlib.sha384()
            d_sha512 = hashlib.sha512()
            # update hashing with partial byte stream buffer
            for buf in iter(partial(f.read, 128), b''):
                d_md5.update(buf)
                d_sha1.update(buf)
                d_sha224.update(buf)
                d_sha256.update(buf)
                d_sha384.update(buf)
                d_sha512.update(buf)
        # calculate digest for each hash
        md5_hash = d_md5.hexdigest()
        sha1_hash = d_sha1.hexdigest()
        sha224_hash = d_sha224.hexdigest()
        sha256_hash = d_sha256.hexdigest()
        sha384_hash = d_sha384.hexdigest()
        sha512_hash = d_sha512.hexdigest()
        # store hashes for return
        hash_list = [
            md5_hash, 
            sha1_hash, 
            sha224_hash,
            sha256_hash,
            sha384_hash,
            sha512_hash
            ]
        return hash_list


    def gen_report(self):
        """Generate PDF report

        This method generates an HTML formatted report, detailing
        the file system, document information dictionary, and 
        XMP metadata contained within a PDF file. It functions by 
        invoking previously defined methods, capturing their
        return values as variables, and inserting these variable
        values into an HTML structure, part of which is globally
        defined, and part of which is variably defined based on
        factors such as (1) the file's encryption status, (2)
        the success or failure of any decryption efforts, and
        (3) the presence and numbers of any /Info or /Metadata
        references and objects.

        Args:
            file_path: The path (can be full or abbreviated) of
            the file to be tested.
            
            temp_path: The hard-coded truncated path of the 
            temporary PDF files used for decryption and metadata 
            extraction.

            output_path: The path (full or truncated) of the 
            output file.

            password: The password used to decrypt an encrypted
            PDF file. This value defaults to None is no input
            is provided.
        """
        with open(self.output_path, 'w') as text_file:
            # get file system metadata values
            file_sys_meta = BinaryPdfForensics.file_stats(self)
            hash_list = BinaryPdfForensics.file_hashes(self)
            version = BinaryPdfForensics.pdf_magic(self)
            # get encryption status
            crypt_ref = BinaryPdfForensics.get_crypt_ref(self)
            crypt_count = len(crypt_ref[1])
            # insert file system metadatavalues into HTML report
            text_file.write(HTML_TOP.format(
                __gitlab_addr__,
                __version__,
                file_sys_meta[0],
                file_sys_meta[1],
                file_sys_meta[2],
                file_sys_meta[3],
                file_sys_meta[4],
                hash_list[0],
                hash_list[1],
                hash_list[2],
                hash_list[3],
                hash_list[4],
                hash_list[5],
                version[1]))
            # handle encrypted PDFs
            text_file.write(HTML_CRYPT_HEAD)
            if crypt_ref[0] is True:
                decrypt = BinaryPdfForensics.decrypt_file(self)
                text_file.write(HTML_CRYPT_TRUE)
                if decrypt[0] == 0 and decrypt[1] != "":
                    text_file.write(HTML_DECRYPT_PASS_PW.format(
                        str(decrypt[1])))
                elif decrypt[0] == 0 and decrypt[1] == "":
                    text_file.write(HTML_DECRYPT_PASS_DF)
                elif decrypt[1] == "":
                    text_file.write(HTML_DECRYPT_FAIL_DF.format(
                        decrypt[3].decode()))
                else:
                    text_file.write(HTML_DECRYPT_FAIL_PW.format(
                        str(decrypt[1]),
                        decrypt[3].decode()))
            # handle un-encrypted PDFs
            elif crypt_ref[0] is False:
                copy = BinaryPdfForensics.copy_file(self)
                text_file.write(HTML_CRYPT_FALSE)
            # get /Info references and objects
            info_ref = BinaryPdfForensics.get_info_ref(self)
            info_count = len(info_ref[1])
            info_obj = BinaryPdfForensics.get_info_obj(self)
            info_obj_count = len(info_obj[1])
            # get /Metadata references and objects
            xmp_ref = BinaryPdfForensics.get_xmp_ref(self)
            xmp_count = len(xmp_ref[1])
            xmp_obj = BinaryPdfForensics.get_xmp_obj(self)
            xmp_obj_count = len(xmp_obj[1])
            # insert /Info references into HTML report
            text_file.write(HTML_DOC_REF.format(
                str(info_count)))
            for ref in info_ref[1]:
                text_file.write('<p><code>')
                text_file.write(binary_string(ref))
                text_file.write('</code></p>\n')
            # insert /Info objects into HTML reports
            text_file.write(HTML_DOC_OBJ.format(
                str(info_obj_count)))
            for obj in info_obj[1]:
                text_file.write('<p><code>')
                info = binary_string(info_obj[1][obj])
                info_clean = info.replace('<', '&lt;')
                print(info)
                text_file.write(info_clean)
                text_file.write('</code></p>\n')
            # insert /Metadata references into HTML report
            text_file.write(HTML_XMP_REF.format(
                str(xmp_count)))
            for ref in xmp_ref[1]:
                text_file.write('<p><code>')
                text_file.write(binary_string(ref))
                text_file.write('</code></p>\n')
            # insert /Metadata objects into HTML report
            text_file.write(HTML_XMP_OBJ.format(
                str(xmp_obj_count)))
            for obj in xmp_obj[1]:
                text_file.write('<p><code>')
                xml = binary_string(xmp_obj[1][obj])
                print(xml)
                xml_clean = xml.replace('<', '&lt;')
                text_file.write(xml_clean)
                text_file.write('</code></p>\n')
            # add trailer to HTML report
            text_file.write(HTML_BOTTOM.format(
                __email_addr__,
                __email_addr__))


def arg_parser():
    """Argument parser

    Defines argument parser for CLI script. The parser has
    a required subcommand, which defines one of two possible
    operating modes for the parser: (1) single input mode, and
    (2) batch input mode. Single input mode has two required
    arguments, (1) the input PDF file to be analyzed and (2)
    the output file path to write the results, as well as one
    optional argument, (3) a password to decrypt the PDF file.
    Batch input mode has only one required argument: (1) the
    input file directory containing the CSV file with the
    structured batch input data. The parser as a whole has
    additionally an optional argument to quiet the output
    by omitting the utility's title, as well as the parser
    and subparser's built-in help arguments.

    Returns:
        This function returns an argument namespace object
        with elements that vary depending on the chosen mode.
        The object returned by single mode will contain five
        elements: (1) a list of any input path args, (2) a 
        string representing the mode, (3) a string of the 
        output file path (if default) or a list of any output 
        path args, (4) a string of the password value, and 
        (5) a boolean of the quiet value.  The object returned
        by batch mode will contain three elements: (1) a list
        of any input file args, (2) a string represenging the
        mode, and a boolean of the quiet value.

        Example of the argument namespace for single mode:

            Namespace(
                input_name=['methods_of_web_philology.pdf'],
                mode='single',
                output_name='output.html', 
                password='', 
                quiet=False
                )

        Example of the argument namespace for batch mode:

            Namespace(
                input_file=['input.csv'],
                mode='batch',
                quiet=False
                )
    """
    # init arg parser
    parser = argparse.ArgumentParser(
        description = ('PDF Metadata, ' + __version__ +
            ' (' + __gitlab_addr__ + '): ' +
            'An automated utility for extracting metadata ' +
            'from PDF files.') 
        )
    # init arg subparser
    subparsers = parser.add_subparsers(
        title = 'modes',
        dest = 'mode',
        help = 'input mode options',
        )
    subparsers.required = True
    # init single subparser
    single_parser = subparsers.add_parser(
        'single', 
        help = 'single input'
        )
    # add single input
    single_parser.add_argument(
        '-i', 
        '--input', 
        action = 'store', 
        nargs = 1,
        type = str,
        help = 'input path and name',
        dest = 'input_name',
        required = True
        )
    # add single output
    single_parser.add_argument(
        '-o', 
        '--output', 
        action = 'store', 
        nargs = 1,
        type = str,
        help = 'output path and name',
        dest = 'output_name',
        default = 'output.html',
        required = True
        )
    # add single password
    single_parser.add_argument(
        '-p', 
        '--password', 
        action = 'store', 
        nargs = 1,
        type = str,
        help = 'password for PDF decryption',
        dest = 'password',
        default = ''
        )
    # init batch subparser
    batch_parser = subparsers.add_parser(
        'batch', 
        help = 'batch input'
        )
    # add file input
    batch_parser.add_argument(
        '-f', 
        '--file', 
        action = 'store',
        nargs = 1,
        type = str,
        help = 'file with batch input parameters', 
        dest = 'input_file',
        required = True
        )
    # quiet option argument
    parser.add_argument(
        '-q',
        '--quiet',
        action = 'store_true',
        help = 'quiet mode suppresses title',
        dest = 'quiet',
        default = False
        )
    args = parser.parse_args()
    return args


def print_title():
    """Print utility title

    This function prints the title of the utility, using color
    and bolding class methods where needed.
    """
    print(
        Color.BOLD + TITLE.format(
        Color.RED    + 'P' + Color.END + Color.BOLD,
        Color.RED    + 'D' + Color.END + Color.BOLD,
        Color.RED    + 'F' + Color.END + Color.BOLD,
        Color.RED    + '•' + Color.END + Color.BOLD,
        Color.BLUE   + 'M' + Color.END + Color.BOLD,
        Color.BLUE   + 'E' + Color.END + Color.BOLD,
        Color.BLUE   + 'T' + Color.END + Color.BOLD,
        Color.BLUE   + 'A' + Color.END + Color.BOLD,
        Color.PURPLE + 'D' + Color.END + Color.BOLD,
        Color.PURPLE + 'A' + Color.END + Color.BOLD,
        Color.PURPLE + 'T' + Color.END + Color.BOLD,
        Color.PURPLE + 'A' + Color.END + Color.BOLD,
        __version__ + Color.END))


def de_dupe_list(list_var):
    """Removes duplicate elements from list

    This function reads the input list, and creates a new
    blank list. It iterates over each element of the input
    list and adds each unique elelemnt to the new list, with
    any duplicated elements being ignored.

    Args:
        list_var: Any list object.

    Returns:
        This function returns a list of unique elements from
        the input arg.
    """
    new_list = []
    for element in list_var:
        if element not in new_list:
            new_list.append(element)
    return new_list


def binary_string(binary_obj):
    """Strips non-stringable characters from binary object

    This function reads an input binary object, and creates a 
    new list. It iterates overy each byte in the binary object.
    If the byte can be decoded into a character, the character
    is added to the new list. The list characters are then
    joined into a string, and any framing whitespace is 
    stripped, as well as any repeating '\n' characters within
    the string.

    Args:
        binary_obj: Any given binary object.

    Returns:
        This function returns a string with all the stringable
        characters from the input binary.
    """
    chr_list = []
    for byte in binary_obj:
        if byte not in [0]:
            try:
                chr_list.append(chr(byte))
            except:
                pass
    chr_string = ''.join(chr_list) \
                   .strip() \
                   .replace('þ', '').replace('ÿ', '').replace('\r', '')
    clean_string = re.sub(
        r'xmpmeta>[\s]*<[?]xpacket',
        'xmpmeta>\n<?xpacket',
        chr_string
        )
    return clean_string


def clean_up_msg(clean_up):
    """Prints the status of the temp_clean() method

    Args:
        clean_up: A boolean which describes whether the method
        succeeded or failed.
    """
    if clean_up is True:
        print("[+] Temporary directory removed: './tmp'\n")
    elif clean_up is False:
        print("[-] Temporary directory not removed: './tmp'\n")


def read_csv(input_file):
    """CSV reader and validator

    This function reads an input file, tests it to ensure that
    (1) it is a CSV, and (2) conforms to the column number
    requirements (either 2 or 3 columns per row). Once the 
    check is performed, a Boolean value is generated. If the
    data passes the check, it is extracted as a list of lists.

    Args:
        input_file: A given string representing the file name
        and/or path or a CSV file.

    Returns:
        This function returns a tuple. The first element is the
        Boolean value, indicating whether or not the input file
        passed all of the validation checks. The second element
        is a list of lists comprising the rows and column 
        elements of the read CSV file.

    Raises:
        SystemExit: There are three non-zero exit codes that are
        defined in this function, depending on the specific
        type of failure that led to the abend.
    """
    csv_data = []
    try:
        with open(input_file, 'r') as csv_file:
            csv_reader = csv.reader(csv_file, 
                                    delimiter=',', 
                                    quotechar='"')
            row_num = 0
            for row in csv_reader:
                row_length = len(row)
                if row_length == 3:
                    csv_check = True
                    row_num = row_num + 1
                    csv_data.append(row)
                elif row_length == 2:
                    csv_check = True
                    row_num = row_num + 1
                    row.append('')
                    csv_data.append(row)
                else:
                    csv_check = False
                    break
    except FileNotFoundError:
        print("[-] '{0}' cannot be found\n".format(input_file))
        raise SystemExit(3)
    except UnicodeDecodeError:
        print("[-] Error reading file, does not appear to be "
              "a CSV")
        raise SystemExit(6)
    if csv_check is False:
        print("[-] Error reading CSV, "
              "row {0} has {1} column(s)"
              .format(row_num, row_length))
        raise SystemExit(5)
    return (csv_check, csv_data)


def input_main(arg_list):
    """Main data input

    This function takes the required arguments from the CLI and
    creates a new BinaryPdfForensics object. This object is
    tested using the magic method to ensure that the input
    file is truly a PDF. If it is not, the script exits
    appropriately. If it is, an attempt is made to generate
    a metadata report.

    Args:
        arg_list: The list of structured data elements extracted
        from the CLI arguments.

    Raises:
        SystemExit: There are four non-zero exit codes that are
        defined in this function, depending on the specific
        type of failure that led to the abend.
    """
    new_file = BinaryPdfForensics(
        arg_list[0],
        arg_list[1],
        arg_list[2])
    # test for magic number in PDF file
    with open(new_file.file_path, 'rb') as raw_file:
        print(new_file.file_path)
    magic = new_file.pdf_magic()
    if magic[0] is True:
        print("[+] '{0}' is a valid file type: {1}". format(
            arg_list[0],
            magic[1]))
    elif magic[0] is False and magic[1] == 'Non-PDF File':
        print("[-] '{0}' is not a valid PDF file\n".format(
            arg_list[0]))
        raise SystemExit(1)
    elif magic[0] is False and magic[1] == 'Directory':
        print("[-] '{0}' is a directory\n".format(
            arg_list[0]))
        raise SystemExit(2)
    elif magic[0] is False and magic[1] == 'File Not Found':
        print("[-] '{0}' cannot be found\n".format(
            arg_list[0]))
        raise SystemExit(3)
    # generate PDF metadata report
    new_file.gen_report()
    try:        
        new_file.gen_report()
        print("[+] Report generated as file: '{0}'".format(
            arg_list[1]))
        clean_up = new_file.temp_clean()
        clean_up_msg(clean_up)
    except Exception as e:
        print("[-] Error generating report: {0}".format(
            str(e)))
        clean_up = new_file.temp_clean()
        clean_up_msg(clean_up)
        raise SystemExit(4)


def single_input(args):
    """Single mode input

    This function takes the parsed single mode arguments, and
    extracts the three values needed for the main input
    function: (1) the input file name, (2) the output file
    name, and (3) any given password for the PDF. The
    extracted arguments are then passed into the main input
    function.

    Args:
        args: parsed arguments passed via the CLI.
    """
    if type(args.output_name) == str:
        output_arg = args.output_name
    elif type(args.output_name) == list:
        output_arg = args.output_name[0]
    arg_list = [args.input_name[0], 
                output_arg, 
                args.password]
    input_main(arg_list)


def batch_input(args):
    """Batch mode input

    This function takes the parsed batch mode arguments and
    extracts the input file name. This is passed through the
    CSV validator and data extractor. If the input file passes
    the validation tests, each row is iteratively passed
    through the main input function.

    Args:
        args: parsed arguments passed via the CLI.
    """
    if type(args.input_file) == str:
        file_arg = args.input_file
    elif type(args.input_file) == list:
        file_arg = args.input_file[0]
    csv_data = read_csv(file_arg)
    if csv_data[0] is True:
        for arg_list in csv_data[1]:
            input_main(arg_list)


def main():
    """Main application function

    This function parses the CLI arguments. Based on the 
    quiet argument, it may or may not print the script's 
    title. Based on the mode argument, it will call either
    the single or batch mode input function.
    """
    args = arg_parser()
    if args.quiet is False:
        print_title()
    if args.mode == 'single':
        single_input(args)
    elif args.mode == 'batch':
        batch_input(args)


if __name__ == '__main__':
    main()
